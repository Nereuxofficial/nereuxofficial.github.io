<!doctype html><html lang=en><head><title>Writing a BitBoard in Rust Pt. 2: The Game State :: Nereuxofficials old Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Now that we have a bitboard to store the pieces, we need a way to store the game state"><meta name=keywords content="bitboard,chess,rust"><meta name=robots content="noodp"><link rel=canonical href=https://nereuxofficial.github.io/posts/bitboard-rust-2/><link rel=stylesheet href=https://nereuxofficial.github.io/assets/style.css><link rel=stylesheet href=https://nereuxofficial.github.io/assets/red.css><link rel=apple-touch-icon href=https://nereuxofficial.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://nereuxofficial.github.io/img/favicon/red.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Writing a BitBoard in Rust Pt. 2: The Game State"><meta property="og:description" content="Now that we have a bitboard to store the pieces, we need a way to store the game state"><meta property="og:url" content="https://nereuxofficial.github.io/posts/bitboard-rust-2/"><meta property="og:site_name" content="Nereuxofficials old Blog"><meta property="og:image" content="https://nereuxofficial.github.io/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-09-14 08:11:54 +0200 +0200"></head><body class=red><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Home</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><ul class=menu__sub-inner><li class=menu__sub-inner-more-trigger>Show more ▾</li><ul class="menu__sub-inner-more hidden"><li><a href=/donate>Donate</a></li><li><a href=https://nereux.blog>New Blog</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><li><a href=/donate>Donate</a></li><li><a href=https://nereux.blog>New Blog</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://nereuxofficial.github.io/posts/bitboard-rust-2/>Writing a BitBoard in Rust Pt. 2: The Game State</a></h1><div class=post-meta><span class=post-date>2021-09-14</span>
<span class=post-reading-time>:: 3 min read (626 words)</span></div><span class=post-tags>#<a href=https://nereuxofficial.github.io/tags/bitboard/>bitboard</a>&nbsp;
#<a href=https://nereuxofficial.github.io/tags/chess/>chess</a>&nbsp;
#<a href=https://nereuxofficial.github.io/tags/rust/>rust</a>&nbsp;</span><div class=post-content><div><p>In the last blog post we created <code>BitBoard</code>s and stored them inside a <code>Position</code>.
To evaluate a position we need more than the positioning of the pieces sometimes though. En-passant is a good example
of this:
<a href=https://lichess.org/editor/2k5/pp6/5p2/5Pp1/6B1/8/5PPP/6K1_w_-_-_0_1><img src=./images/En_Passant_position.png alt="2k5/pp6/5p2/5Pp1/6B1/8/5PPP/6K1 w - - 0 1"></a>
In this position capturing the pawn on g5 with En Passant is the best move if available since it allows us to promote a
pawn. Just looking at the board though we cannot be sure that en passant is a legal move.</p><h2 id=explanation>Explanation<a href=#explanation class=hanchor arialabel=Anchor>&#8983;</a></h2><p>So we need additional information in order to evaluate the position. This will be stored in the struct called <code>State</code>,
which contains all necessary information to evaluate a position outside the pieces positions.</p><p>So it contains the:</p><ul><li>Castling rights</li><li>Half move counter</li><li>Side to move</li><li>En passant(if possible)</li></ul><p>An implementation can look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// Contains castling_rights, move_clocks, en_passant_square if possible and the side to move
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Debug, Clone, Hash, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>    castling_rights: <span style=color:#a6e22e>CastlingRights</span>,
</span></span><span style=display:flex><span>    en_passant_square: Option<span style=color:#f92672>&lt;</span>Square<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    half_move_counter: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    stm: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order to define castling rights efficiently we do it similar to Stockfish. We define an u8 to store the castling
rights. The first 4 bits are unused and the latter ones are used to store one castling right.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// Castling rights are stored in a [`u8`], which is divided into the following parts:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// ```text
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// 0 1 0 1   1                1               0                0
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// ^^^^^^^   ^                ^               ^                ^
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// unused    Black queen side Black king side White queen side White king side
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// ```
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Debug, Clone, Hash, Eq, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CastlingRights</span>(<span style=color:#66d9ef>u8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> CastlingRights {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>empty</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self(Castling::<span style=color:#66d9ef>NO_CASTLING</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>all</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self::default()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Default <span style=color:#66d9ef>for</span> CastlingRights {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>default</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self(Castling::<span style=color:#66d9ef>ANY_CASTLING</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And a helper struct to more easily use <code>CastlingRights</code>, which I put in my defs.rs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// Provides labels for the [`CastlingRights`]
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Castling</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Castling {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>NO_CASTLING</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>WHITE_00</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000001</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>WHITE_000</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000010</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>BLACK_00</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000100</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>BLACK_000</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00001000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>KING_SIDE</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> Self::<span style=color:#66d9ef>BLACK_00</span> <span style=color:#f92672>|</span> Self::<span style=color:#66d9ef>WHITE_00</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>QUEEN_SIDE</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> Self::<span style=color:#66d9ef>BLACK_000</span> <span style=color:#f92672>|</span> Self::<span style=color:#66d9ef>WHITE_000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>WHITE_CASTLING</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> Self::<span style=color:#66d9ef>WHITE_00</span> <span style=color:#f92672>|</span> Self::<span style=color:#66d9ef>WHITE_000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>BLACK_CASTLING</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> Self::<span style=color:#66d9ef>BLACK_00</span> <span style=color:#f92672>|</span> Self::<span style=color:#66d9ef>BLACK_000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>ANY_CASTLING</span>: <span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> Self::<span style=color:#66d9ef>BLACK_CASTLING</span> <span style=color:#f92672>|</span> Self::<span style=color:#66d9ef>WHITE_CASTLING</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we also need a way to represent squares in order to use en_passant_square, which we can nicely do with an enum in
Rust:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Hash, PartialEq, Eq, Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Represents a single square on the board.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// # Representation
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// 1 is A1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// 2 is B1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// 64 is H8
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Square</span>(<span style=color:#66d9ef>usize</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Labels for every [`Square`] on the board.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[repr(usize)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[rustfmt::skip]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>SquareLabels</span> {
</span></span><span style=display:flex><span>    None,
</span></span><span style=display:flex><span>    A1, B1, C1, D1, E1, F1, G1, H1,
</span></span><span style=display:flex><span>    A2, B2, C2, D2, E2, F2, G2, H2,
</span></span><span style=display:flex><span>    A3, B3, C3, D3, E3, F3, G3, H3,
</span></span><span style=display:flex><span>    A4, B4, C4, D4, E4, F4, G4, H4,
</span></span><span style=display:flex><span>    A5, B5, C5, D5, E5, F5, G5, H5,
</span></span><span style=display:flex><span>    A6, B6, C6, D6, E6, F6, G6, H6,
</span></span><span style=display:flex><span>    A7, B7, C7, D7, E7, F7, G7, H7,
</span></span><span style=display:flex><span>    A8, B8, C8, D8, E8, F8, G8, H8,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And lastly we need to add the <code>State</code> to the <code>Position</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// A Position contains everything necessary to calculate moves and evaluate a position.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Debug, Clone, Hash, PartialEq, Eq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Position</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// The board for each side
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    bb_sides: [BitBoard; <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// BitBoards for all pieces and each side
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    bb_pieces: [[BitBoard; <span style=color:#ae81ff>6</span>]; <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// State contains all relevant information for evaluating a position outside the pieces.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    state: <span style=color:#a6e22e>State</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=credits-and-further-reading>Credits and further reading<a href=#credits-and-further-reading class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Many articles and projects have helped me in the writing of this Blog Post, notably:</p><ul><li>the <a href=https://www.chessprogramming.org/Bitboards>Chess Programming Wiki</a></li><li>the <a href=https://rustic-chess.org/>rustic project</a></li><li>the <a href=https://github.com/peterellisjones/rust_move_gen>rust-move-gen</a></li><li>the <a href="https://youtube.com/playlist?list=PLZ1QII7yudbc-Ky058TEaOstZHVbT-2hg">Chess Engine in C Series</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://nereuxofficial.github.io/posts/esp32-ws2812-dino-light/><span class=button__icon>←</span>
<span class=button__text>Making a Dino Light with the ESP32 and WS2812</span></a></span>
<span class="button next"><a href=https://nereuxofficial.github.io/posts/bitboard-rust/><span class=button__text>Writing a BitBoard in Rust Pt. 1: The Basics</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://nereuxofficial.github.io/assets/main.js></script>
<script src=https://nereuxofficial.github.io/assets/prism.js></script></div></body></html>